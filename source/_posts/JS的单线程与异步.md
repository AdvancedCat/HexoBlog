---
title: JS的单线程与异步
date: 2017-12-18 14:41:56
tags: ['Javascript']
---

我们常说JavaScript是单线程的，那么应该怎么来认识这句话呢？它和异步又是什么关系呢？

# 单线程与异步
在一门语言中，单线程和异步是自相矛盾的。JS本身是单线程的，那么它就不是异步。但是，万事都有个但是，它的宿主环境是多线程的。JS常见的宿主环境是浏览器或Node端，宿主环境让JS通过某种方式（事件驱动）拥有了异步的行为。因为事件驱动让JS的机制非常简单高效。

# 浏览器宿主
在各个宿主环境中，仅仅分配一个主线程给JS引擎去执行任何或函数，且一次只能执行一个任务。那么在浏览器里充满很多不同任务，且大多任务是非常耗时的，比如网络请求，定时器和事件监听。如果只让一个线程去完成的话，显然很容易阻塞。因此浏览器为这些耗时任务开辟了另外的线程，主要包括http请求线程，浏览器定时触发器，浏览器事件触发线程。如下图：
![](/img/JS宿主浏览器环境.jpg)
浏览器内存常驻线程：
* 浏览器 GUI 渲染线程
* JavaScript 引擎线程
* 浏览器定时触发器线程
* 浏览器事件触发线程
* 浏览器 http 异步请求线程

# 任务队列
那既然只有一个主线程在跑JS引擎，那么其他线程的任务完成后如何通知主线程呢？答案是回调函数，整个程序都是事件驱动的，每个事件都会绑定一个回调函数，比如如下的定时器任务：
```js
setTimeout(function(){
    console.log('定时结束')
}, 50)
```
首先JS主线程读取到setTimeout，会将这个任务交给浏览器定时触发器异步执行，当50ms过去后，浏览器定时触发器会再将回调函数重新压入任务队列的最后。其他异步任务也是如此，整个程序就是依靠这样一个个事件驱动起来的。所以说，JS一直都是单线程的，而浏览器才是实现异步的真正“主谋”

# 三者关系
上面我们说到了三个东西：JS主线程、任务队列、浏览器多线程。那么它们之间有什么关系呢？下面的图可以看出它们的关系：
![](/img/JS主线程任务队列.jpg)
(图片摘自Philip Roberts的演讲《Help, I'm stuck in an event-loop》)
图片中`heap+stack`构成JS引擎主线程，`callback queue`是任务队列，`Web APIs`则是上面提到的浏览器异步任务线程。
函数的执行就是通过进栈和出栈实现的，比如图中有一个foo()函数，主线程把它推入栈中，在执行函数体时，发现还需要执行上面的那几个函数，所以又把这几个函数推入栈中，等到函数执行完，就让函数出栈。等到stack清空时，说明一个任务已经执行完了，这时就会从callback queue中寻找下一个人任务推入栈中（这个寻找的过程，叫做event loop，因为它总是循环的查找任务队列里是否还有任务）。

# 如何利用异步
浏览器维护了五个常驻线程，那么我们是否可以利用一下呢？答案是可以的，比如我们书写的同步代码是一个比较耗时的，比如遍历一个很大的数组，那么可以利用：
* 定时器
```js
// f1是一个非常耗时的过程
function f1(callback){
    setTimeout(function(){
        // f1 的代码
        callback();
    },0);
}
f1(f2);
```
* 事件触发
```js
// jQuery可以为dom元素绑定自定义事件，而这个事件是由事件触发线程完成的
$f1.on('custom',f2);  //这里绑定事件以jQuery写法为例
function f1(){
    setTimeout(function(){
        // f1的代码
        $f1.trigger('custom');
    },0);
}
```

# Q&A
Q:ajax请求是不是异步的？
A:从上面我们知道，浏览器会为http请求单独开辟线程处理，因此ajax请求是异步的

Q:界面渲染线程与JS主线程的关系
A:界面渲染线程与JS主线程是互斥的，主线程在执行时，界面渲染线程就会被挂起。
在执行<script>中内容时，浏览器会切换到JavaScript引擎所在的线程，此时渲染引擎所在的线程会阻塞，故其后元素的解析和渲染会暂停。把<script>放到紧跟</body>之前的位置。这样就不会影响需要放到页面上的UI元素的解析了。这样的好处就是，用户能即使看到页面上的UI元素，而防止出现了浏览器白屏等现象。

Q:静态资源和动态资源
A:一般而言，html中通过script定义的资源属于静态资源，这些资源的请求会阻塞dom树的构建。而通过js的createElement方法塞入到html中的资源属于动态资源，这种资源的请求并不会阻塞浏览器的渲染（因为塞入到dom的script标签的async属性是true）。因此如果资源可以异步获取，就可以通过动态资源的形式加载。


参考资料：
* JavaScript的单线程和异步: https://zhuanlan.zhihu.com/p/23659122
